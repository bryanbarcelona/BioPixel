import os

import numpy as np
import glob
from PIL import Image, ImageDraw
import cv2

from utils import image_tools


class Cropper:
    
    def __init__(self, masks: np.ndarray, image_array: np.ndarray):
        self._masks = masks
        self._image_array = image_array
        self._mask_ids = self.count_masks()
        self.cropped_cells = self.crop_cells()
    
    
    def count_masks(self):
        unique_masks = np.unique(self._masks)
        unique_masks = unique_masks[unique_masks != 0]  # Exclude the background
        return unique_masks
 
    def get_crop_params(self, masks: np.ndarray, mask_id: int) -> tuple | np.ndarray:
        """
        Calculate square crop parameters for a given mask within the image.

        This function calculates the square crop parameters for the specified mask
        within the image represented by the provided masks array. It finds the
        minimum bounding box around the mask and adjusts it to be square with
        optional padding.

        Parameters:
        masks (np.ndarray): A 2D NumPy array representing the image masks.
        mask_id (int): The identifier of the mask to process.

        Returns:
        Tuple[int, int, int, int]: A tuple containing:
            - The top coordinate of the square crop.
            - The bottom coordinate of the square crop.
            - The left coordinate of the square crop.
            - The right coordinate of the square crop.

        Additionally, a binary mask (NumPy array) is returned separately.
        """

        # Find the pixels that are within the specified mask
        rows, cols = np.where(masks == mask_id)

        # Create a binary mask where mask pixels are set to 1
        zero_mask = (masks == mask_id).astype(np.uint8)

        # # Define the kernel
        # kernel = np.ones((99, 99), dtype=np.uint8)

        # # Dilate the zero mask
        # zero_mask = cv2.dilate(zero_mask, kernel, iterations=1)

        # Determining the boundaries of the specified mask
        if len(rows) > 0 and len(cols) > 0:
            min_row, max_row = np.min(rows), np.max(rows)
            min_col, max_col = np.min(cols), np.max(cols)

            return (min_row, max_row, min_col, max_col), zero_mask

    def crop_cells(self):
        for mask_id in self._mask_ids:
            crop_params, zero_mask = self.get_crop_params(self._masks, mask_id)
            if crop_params:
                top, bottom, left, right = crop_params

                # Apply zero_mask to the image_array to black out non-mask areas
                masked_image = np.where(zero_mask == 1, self._image_array, 0)

                # Crop the masked image
                # Crop the masked image, focusing on the last two dimensions
                slices = [slice(None)] * (masked_image.ndim - 2) + [slice(top, bottom), slice(left, right)]
                cropped_image = masked_image[tuple(slices)]

                #cropped_image = self._image_array[top:bottom, left:right]

                yield cropped_image
'''
def find_center_mask(npy_file):
    """
    This function uses the detected masks and finds the centermost mask. It then determines the crop size for the image.
    The crop size is calculated by finding the larger of the X and Y dimensions and adds 7% padding to the crop based
    on this.

    Parameters:
    path (str): The path to the input .npy file containing the masks generated by cellpose.
        
    output_type: None 

    Returns:
    X/Y coordinates for the crop box 
    """
    #npy_path = os.path.splitext(tif_file)[0] + '_fullblend_seg.npy'
    segmentation_npy = np.load(npy_file, allow_pickle=True).item()

    # Get the masks array from the loaded segmentation
    masks = segmentation_npy['masks']
    
    # Get the individual mask numbers and their pixel counts
    unique_values, counts = np.unique(masks, return_counts=True)

    # Calculate the center of the image and determining which mask is in the center
    rows, cols = masks.shape
    center_row = rows // 2
    center_col = cols // 2
    center_value = masks[center_row, center_col]

    if center_value == 0:
        print(f"There is no central cell found in this image. Switching to find any cells that dont touch the edge.")
        return None, None

    cropbox, zero_mask = get_square_crop_params(masks, center_value)

    return cropbox, zero_mask

def find_largest_non_edge_mask(npy_file):
    """
    This function finds the largest mask that does not touch the edges of the image
    among the masks provided in the .npy file.

    Parameters:
    npy_file (str): The path to the input .npy file containing the masks generated by cellpose.

    Returns:
    X/Y coordinates for the crop box and the largest non-edge mask
    """
    segmentation_npy = np.load(npy_file, allow_pickle=True).item()

    # Get the masks array from the loaded segmentation
    masks = segmentation_npy['masks']

    # Get the image dimensions
    rows, cols = masks.shape

    largest_non_edge_mask = None
    largest_non_edge_area = 0
    value_of_mask = 0
    # Iterate through unique mask values
    unique_values, counts = np.unique(masks, return_counts=True)
    for value, count in zip(unique_values, counts):
        if value == 0:
            continue  # Skip background mask

        # Find the pixels that belong to the current mask
        mask_pixels = np.where(masks == value)

        # Calculate the bounding box for the mask
        min_row, max_row = np.min(mask_pixels[0]), np.max(mask_pixels[0])
        min_col, max_col = np.min(mask_pixels[1]), np.max(mask_pixels[1])

        # Check if the mask touches the image edges
        if (
            min_row > 0 and max_row < rows - 1 and
            min_col > 0 and max_col < cols - 1
        ):
            # Calculate the mask area
            mask_area = count

            # Update if this is the largest non-edge mask found so far
            if mask_area > largest_non_edge_area:
                largest_non_edge_area = mask_area
                largest_non_edge_mask = (min_row, max_row, min_col, max_col)
                value_of_mask = value

    if largest_non_edge_mask is None:
        print("No non-edge mask found.")
        return None, None

    cropbox, zero_mask = get_square_crop_params(masks, value_of_mask)

    return cropbox, zero_mask

def find_largest_mask(npy_file: str, size_threshold: int):
    """
    This function finds the largest mask among the masks provided in the .npy file regardless of position.

    Parameters:
    npy_file (str): The path to the input .npy file containing the masks generated by cellpose.
    size_threshold (int): Threshold percentage for the largest mask. The percentage is input as an integer, i.e.
                        2% is 2

    Returns:
    X/Y coordinates for the crop box and the largest mask
    """
    segmentation_npy = np.load(npy_file, allow_pickle=True).item()

    # Get the masks array from the loaded segmentation
    masks = segmentation_npy['masks']

    largest_mask = None
    largest_mask_area = 0
    value_of_mask = 0

    # Iterate through unique mask values
    unique_values, counts = np.unique(masks, return_counts=True)
    for value, count in zip(unique_values, counts):
        if value == 0:
            continue  # Skip background mask

        # Calculate the mask area
        mask_area = count

        # Update if this is the largest mask found so far
        if mask_area > largest_mask_area:
            largest_mask_area = mask_area
            largest_mask = masks == value
            value_of_mask = value

    if largest_mask is None:
        print("No mask found.")
        return None, None

    total_image_area = masks.size  # Total number of pixels in the image
    largest_mask_percentage = (largest_mask_area / total_image_area) * 100

    if largest_mask_percentage < size_threshold:
        print(f"The largest mask is too small: {largest_mask_percentage:.2f}% of the total image.")
        return None, None

    cropbox, zero_mask = get_square_crop_params(masks, value_of_mask)

    return cropbox, zero_mask

def find_approximate_center_cell(png_file: str):
    
    image = cv2.imread(png_file)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    gray = cv2.convertScaleAbs(gray, alpha=1.5, beta=100)

    threshold = np.mean(gray)

    # Apply thresholding to the image
    binary_mask = cv2.threshold(gray, threshold, 255, cv2.THRESH_BINARY)[1]

    # Apply a morphological closing operation to the image
    kernel = np.ones((3, 3), np.uint8)
    binary_mask = cv2.morphologyEx(binary_mask, cv2.MORPH_CLOSE, kernel)

    # Find the contours on the image
    contours, hierarchy = cv2.findContours(binary_mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    # Sort the contours by area
    contours = sorted(contours, key=cv2.contourArea, reverse=True)

    # Select the largest contour
    largest_contour = contours[0]

    # Get the convex hull of the largest contour
    convex_hull = cv2.convexHull(largest_contour)

    # Create a blank image the same size as the input image and set all of the pixels to zero
    mask = np.zeros(gray.shape, dtype=np.uint8)

    # Draw the convex hull on the blank image in white
    cv2.drawContours(mask, [convex_hull], -1, (255, 255, 255), -1)

    # Create a blank image the same size as the input image and set all of the pixels to zero
    mask = np.zeros(gray.shape, dtype=np.uint16)

    # Fill the convex hull with white
    cv2.fillPoly(mask, [convex_hull], (255, 255, 255))

    cropbox, zero_mask = get_square_crop_params(mask, 255)

    return cropbox, zero_mask

def crop_tif(to_be_cropped: str | list, tif_location="TIF", png_location="Detection", npy_location="Detection", detected_suffix="detectable"):
    """
    tif_location: relative path from main experiment directory to tiff files
    png_location: relative path from main experiment directory to png files
    npy_location: relative path from main experiment directory to npy files
    """

    if not isinstance(to_be_cropped, (str, list)):
        raise ValueError(f"Input must be either a valid folder path (str) or a list of valid .npy or .png file paths not a {type(input)}.")
    
    if isinstance(to_be_cropped, str):
        if not os.path.exists(to_be_cropped) or (not os.path.isdir(to_be_cropped) and not os.path.isfile(to_be_cropped)):
            raise ValueError("Input must be a valid path (str).")
        if os.path.isfile(to_be_cropped):
            to_be_cropped = [to_be_cropped]
        elif os.path.isdir(to_be_cropped):
            to_be_cropped = glob.glob(f"{to_be_cropped}\\{npy_location}\\*.npy")

    if isinstance(to_be_cropped, list):
        for item in to_be_cropped:
            if not isinstance(item, str):
                raise ValueError("Each item in the list must be a string.")
            if not os.path.isfile(item) or not item.endswith(('.npy', '.png')):
                raise ValueError("Each item in the list must be a valid .npy or .png file path (str).")
    
    for current_crop in to_be_cropped:
        if os.path.isfile(current_crop):
            if current_crop.endswith('.npy'):
                parent_directory = os.path.dirname(current_crop)
                parent_directory = parent_directory.split(npy_location)[0]
                print(f"Parent directory: {parent_directory}")
                image_name = os.path.splitext(os.path.basename(current_crop))[0].split(f"_{detected_suffix}")[0]
                print(f"npy is {image_name}")
            elif current_crop.endswith('.png'):
                parent_directory = os.path.dirname(current_crop)
                parent_directory = parent_directory.split(png_location)[0]
                print(f"Parent directory: {parent_directory}")
                image_name = os.path.splitext(os.path.basename(current_crop))[0].split(f"_{detected_suffix}")[0]
                print(f"png is {image_name}")
            npys = [f"{parent_directory}{npy_location}\\{image_name}_{detected_suffix}_seg.npy"]

        for npy in npys:
            
            # Create the directory if it does not exist
            if not os.path.exists(f"{parent_directory}Cropped {tif_location}"):
                os.makedirs(f"{parent_directory}Cropped {tif_location}")

            tif = f"{parent_directory}{tif_location}\\{image_name}.tif"
            tif_output = f"{parent_directory}Cropped {tif_location}\\{image_name}_cropped.tif"
            png = f"{parent_directory}{png_location}\\{image_name}_{detected_suffix}.png"
            if not os.path.exists(npy):
                print(f"NPY: {npy} does not exist.")
                continue
            if not os.path.exists(png):
                print(f"PNG: {png} does not exist.")
                continue
            if not os.path.exists(tif):
                print(f"TIF: {tif} does not exist.")
                continue

            output_filename = npy.replace("_seg.npy", "_cropbox.png")

            cropbox, zero_mask = find_center_mask(npy)
            if cropbox is None:
                cropbox, zero_mask = find_largest_non_edge_mask(npy)
            if cropbox is None:
                cropbox, zero_mask = find_largest_mask(npy, 8)
            if cropbox is None:
                cropbox, zero_mask = find_approximate_center_cell(png)
            
            if cropbox:
                
                image, metadata, xy_cal, config = image_tools.load_5D_tif(tif)
                print(f"Zeromask: {zero_mask.shape}")
                print(f"Image: {zero_mask.shape[-2:]}")
                if zero_mask.shape != image.shape[-2:]:
                    raise ValueError("Mask shape must match the last two dimensions of the array.")

                # Expand the mask to match the dimensions of the 5D array (TZCYX)
                zero_mask = zero_mask[np.newaxis, np.newaxis, np.newaxis, :, :]

                # Apply the mask to the 5D array using broadcasting
                image = image * zero_mask

                original_height = image.shape[3]
                original_width = image.shape[4]

                top, bottom, left, right = cropbox

                new_height = original_height - (top + bottom)
                new_width = original_width - (left + right)

                image = image[:, :, :, top:bottom, left:right]

                ranges, minimum_value, maximum_value = image_tools.get_ranges(image)

                image_tools.save_tif(image, tif_output, metadata["Info"], xy_cal, config, ranges, minimum_value, maximum_value)

                print(f"Image with crop box saved as {output_filename}")
            else:
                print("No cropbox generated")

'''